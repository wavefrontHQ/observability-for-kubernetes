---
apiVersion: v1
kind: ConfigMap
metadata:
  name: wavefront-egress-spans-script
  namespace: {{ .Namespace }}
  labels:
    purpose: cron-script
data:
  script.pxl: |
    # px:set max_output_rows_per_table=1500
    import px


    def exclude_known_namespaces(df):
      '''Exclude namespaces which are known to be noise.

      Args:
        @df: The DataFrames to filter.
      '''
      
      # Exclude DataFrames from kube-system
      #
      # It is not useful to see metrics related to the functioning of Kubernetes's system-components (such as the CNI,
      # core-dns, aws-node, etc)
      df = df[df.source_namespace != 'kube-system']
      df = df[df.source_namespace != '{{ .Namespace }}']
      df = df[df.source_namespace != 'olm']
      df = df[df.source_namespace != 'pl']
      df = df[df.source_namespace != 'px-operator']
      
      # Exclude DataFrames from aria-k8s
      #
      # This namespace is where the k8s-collector and telegraf-collector live. Excluding this namespace ensures that data
      # sent to Lemans from telegraf will not be re-reported by Pixie (since sending to Lemans happens over HTTP(s)
      df = df[df.source_namespace != 'aria-k8s']
      
      return df
    
    
    def exclude_known_req_path(df):
      '''Exclude req_path values which are known to be noise.

      Args:
        @df: The DataFrames to filter.
      '''
      # Exclude DataFrames from liveness checks
      #
      # This endpoint is common in Kubernetes pods for checking liveness of a Pod.
      df = df[df.req_path != '/healthz']
      df = df[df.req_path != '/health']
      
      # Exclude DataFrames from readiness checks
      #
      # This endpoint is common in Kubernetes pods for checking readiness of a Pod.
      df = df[df.req_path != '/readyz']
      df = df[df.req_path != '/ready']
      
      return df
    
    
    def exclude_non_egress_traffic(df):
      '''Exclude non-ingress traffic

      Args:
        @df: The DataFrames to filter.
      '''
      df.pod = df.ctx['pod']
      df.pod_id = df.ctx['pod_id']
      
      df = df[
        df['trace_role'] == 1]  # trace_role=1 means df was captured from the client-side of the HTTP request/response
      df = df[df.pod_id != '']
      
      return df
    
    
    def remove_ns_prefix(column):
      return px.replace('[a-z0-9\-]*/', column, '')


    def xor(a, b):
      return a + b - 2 * a * b
    
    
    def add_trace_headers(df):
      df.span_id = px.substring(df.source_pod_id, 19, 4) + px.substring(df.source_pod_id, 24, 12)
      
      # If we have 16 decimal places of nanoseconds, then we will potentially have collisions about every 115 days.
      # Because of that, we are xor'ing the time and latency with the intention of generating a more unique trace id.
      trace_id_time_part = "0000000000000000" + px.itoa(xor(px.time_to_int64(df.time_), df.latency))
      df.trace_id = px.substring(df.span_id, 8, 8) + '00000000' + px.substring(trace_id_time_part,
                                                                               px.length(trace_id_time_part) - 16, 16)
      return df
    
    
    # Assumes only server side http events (i.e. trace_role=2)
    def add_source_dest_columns(df):
      df.source_pod_id = df.pod_id
      df.source_pod = remove_ns_prefix(df.pod)
      df.source_deployment = remove_ns_prefix(px.pod_id_to_deployment_name(df.pod_id))
      df.source_deployment = px.select(df.source_deployment != '', df.source_deployment, 'none')
      df.source_service = remove_ns_prefix(px.pod_id_to_service_name(df.pod_id))
      df.source_service = px.select(df.source_service == '', df.source_deployment, df.source_service)
      df.source_service = px.select(df.source_service == '', df.source_pod, df.source_service)
      df.source_service = strip_commas(df.source_service)
      df.source_namespace = px.pod_id_to_namespace(df.pod_id)
      
      df.destination_name = 'external'
      
      return df
    
    
    def add_error_tag(df):
      # We are following pixie's error convention that does not handle errors in 3xx and network errors in response body
      # as defined in the otel spec below:
      # https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http/#status
      # Pixie reference:
      # https://github.com/pixie-io/pixie/blob/ce44943ecc3dc2f029464927534786d968b97558/src/pxl_scripts/px/namespace/namespace.pxl#L200
      df.error = px.select((df.resp_status >= 400), "true", "false")
      
      return df
    
    
    def strip_commas(column):
      return px.replace(',', column, '_')
    
    
    df = px.DataFrame('http_events', start_time=px.plugin.start_time, end_time=px.plugin.end_time)

    df = exclude_known_req_path(df)
    df = exclude_non_egress_traffic(df)
    df = add_source_dest_columns(df)
    df = exclude_known_namespaces(df)
    df = add_trace_headers(df)
    df = add_error_tag(df)
    df = df.head(15000)
    df.start_time = df.time_ - df.latency

    # Strip out all but the actual path value from req_path
    df.req_path = px.uri_recompose('', '', '', 0, px.pluck(px.uri_parse(df.req_path), 'path'), '', '')
    # Replace any Hex IDS from the path with <id>
    df.req_path = px.replace('/[a-fA-F0-9\-:]{6,}(/?)', df.req_path, '/<id>\\1')

    px.export(
      df, px.otel.Data(
        resource={
          # While other Pixie entities use `service.name=source_service`,
          # the Services-OpenTelemetry entity is set up to only show clients so we use `service.name=source_service`.
          
          # OTel Resource Conventions
          'service.name': df.source_service,
          
          # Field used in OpApps cluster to differentiate between manual DT instrumentation and auto-instrumentation
          'origin': 'opapps-auto',
        },
        data=[
          px.otel.trace.Span(
            name=df.req_path,
            start_time=df.start_time,
            end_time=df.time_,
            trace_id=df.trace_id,
            span_id=df.span_id,
            kind=px.otel.trace.SPAN_KIND_CLIENT,
            attributes={
              # NOTE: the integration handles splitting of services.
              
              # Wavefront Conventions
              'service': df.source_service,
              'application': df.source_namespace,
              # We follow pixie's convention of setting an error tag only for a server span.
              'error': df.error,
              '_outboundExternalService': df.destination_name,
              
              # OTEL HTTP Conventions
              'http.status_code': df.resp_status,
              'http.method': df.req_method,
            },
          ),
        ],
      ),
    )
  configs.yaml: |
    otelEndpointConfig:
      insecure: true
      url: wavefront-proxy.{{ .Namespace }}.svc.cluster.local:4317
  cron.yaml: |
    frequency_s: 10